<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/metamapa/controllers/ExportacionController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/metamapa/controllers/ExportacionController.java" />
              <option name="originalContent" value="// controllers/ExportacionController.java&#10;package com.metamapa.controllers;&#10;&#10;import com.metamapa.infrastructure.Outbox.BandejaDeSalida;&#10;import com.metamapa.dtos.output.ContribuyenteOutputDTO;&#10;import com.metamapa.dtos.output.HechoOutputDTO;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.List;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/export&quot;)&#10;@RequiredArgsConstructor&#10;public class ExportacionController {&#10;&#10;    private final BandejaDeSalida outbox;&#10;&#10;    @GetMapping(&quot;/hechos&quot;)&#10;    ResponseEntity&lt;List&lt;HechoOutputDTO&gt;&gt; obtenerHechos(){&#10;        List&lt;HechoOutputDTO&gt; hechos = outbox.pendientesDeEnvio();  // Cambio de findAll() a pendientesDeEnvio()&#10;        outbox.limpiar();  // Cambio de deleteAll() a limpiar()&#10;        return ResponseEntity.status(200).body(hechos);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="// controllers/ExportacionController.java&#10;package com.metamapa.controllers;&#10;&#10;import com.metamapa.infrastructure.Outbox.BandejaDeSalida;&#10;import com.metamapa.dtos.output.ContribuyenteOutputDTO;&#10;import com.metamapa.dtos.output.HechoOutputDTO;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.List;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/export&quot;)&#10;@RequiredArgsConstructor&#10;public class ExportacionController {&#10;&#10;    private final BandejaDeSalida outbox;&#10;&#10;    @GetMapping(&quot;/hechos&quot;)&#10;    ResponseEntity&lt;List&lt;HechoOutputDTO&gt;&gt; obtenerHechos(){&#10;        List&lt;HechoOutputDTO&gt; hechos = outbox.pendientesDeEnvio();  // Cambio de findAll() a pendientesDeEnvio()&#10;        outbox.limpiar();  // Cambio de deleteAll() a limpiar()&#10;        return ResponseEntity.status(200).body(hechos);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/metamapa/domain/Contribucion.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/metamapa/domain/Contribucion.java" />
              <option name="originalContent" value="package com.metamapa.domain;&#10;import jakarta.persistence.*;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Getter;&#10;import lombok.NoArgsConstructor;&#10;import lombok.Setter;&#10;&#10;import java.time.LocalDate;&#10;import java.util.Scanner;&#10;import java.util.List;&#10;&#10;@Getter&#10;@Setter&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@Entity&#10;@Table(name=&quot;contribucion&quot;)&#10;public class Contribucion {&#10;    @Id&#10;    @GeneratedValue(strategy=GenerationType.IDENTITY)&#10;    private Long id;&#10;&#10;    @ManyToOne(fetch = FetchType.LAZY) //solo me cargas al padre cuando lo necesito&#10;    @JoinColumn(name=&quot;contribuyente_id&quot;, nullable=false)&#10;    private Contribuyente contribuyente;&#10;&#10;    @OneToOne(cascade = CascadeType.ALL, orphanRemoval = true)//si elimino la contribucion, elimino el hecho&#10;    @JoinColumn(name=&quot;hecho_id&quot;, nullable=false)&#10;    private Hecho hecho;&#10;&#10;    @OneToOne(cascade = CascadeType.ALL, orphanRemoval = true) //si elimino la contribucion, elimino la revision&#10;    @JoinColumn(name = &quot;revision_id&quot;)&#10;    private Revision revision = new Revision();  // Inicializar automáticamente&#10;&#10;    @Column(name=&quot;exportada&quot;, nullable=false)&#10;    private Boolean exportada = false;  // Valor por defecto&#10;&#10;    @Column(name=&quot;fecha_de_carga&quot;, nullable=false)&#10;    private LocalDate fechaDeCarga;&#10;&#10;&#10;&#10;    //metodos que figuran en el diagrama&#10;    public void editarHecho(){&#10;        //para que ingrese un dato del hecho&#10;        Scanner obj = new Scanner(System.in);&#10;        hecho.setTitulo(obj.nextLine());&#10;        hecho.setDescripcion(obj.nextLine());&#10;        hecho.setCategoria(new Categoria(obj.nextLine()));&#10;        hecho.setFecha(LocalDate.parse(obj.nextLine()));&#10;        hecho.setLugarDeOcurrencia(new Ubicacion(Float.parseFloat(obj.nextLine()), Float.parseFloat(obj.nextLine())));&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.metamapa.domain;&#10;import jakarta.persistence.*;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Getter;&#10;import lombok.NoArgsConstructor;&#10;import lombok.Setter;&#10;&#10;import java.time.LocalDate;&#10;import java.util.Scanner;&#10;import java.util.List;&#10;&#10;@Getter&#10;@Setter&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@Entity&#10;@Table(name=&quot;contribucion&quot;)&#10;public class Contribucion {&#10;    @Id&#10;    @GeneratedValue(strategy=GenerationType.IDENTITY)&#10;    private Long id;&#10;&#10;    @ManyToOne(fetch = FetchType.LAZY) //solo me cargas al padre cuando lo necesito&#10;    @JoinColumn(name=&quot;contribuyente_id&quot;, nullable=false)&#10;    private Contribuyente contribuyente;&#10;&#10;    @OneToOne(cascade = CascadeType.ALL, orphanRemoval = true)//si elimino la contribucion, elimino el hecho&#10;    @JoinColumn(name=&quot;hecho_id&quot;, nullable=false)&#10;    private Hecho hecho;&#10;&#10;    @OneToOne(cascade = CascadeType.ALL, orphanRemoval = true) //si elimino la contribucion, elimino la revision&#10;    @JoinColumn(name = &quot;revision_id&quot;)&#10;    private Revision revision = new Revision();  // Inicializar automáticamente&#10;&#10;    @Column(name=&quot;exportada&quot;, nullable=false)&#10;    private Boolean exportada = false;  // Valor por defecto&#10;&#10;    @Column(name=&quot;fecha_de_carga&quot;, nullable=false)&#10;    private LocalDate fechaDeCarga;&#10;&#10;&#10;&#10;    //metodos que figuran en el diagrama&#10;    public void editarHecho(){&#10;        //para que ingrese un dato del hecho&#10;        Scanner obj = new Scanner(System.in);&#10;        hecho.setTitulo(obj.nextLine());&#10;        hecho.setDescripcion(obj.nextLine());&#10;        hecho.setCategoria(new Categoria(obj.nextLine()));&#10;        hecho.setFecha(LocalDate.parse(obj.nextLine()));&#10;        hecho.setLugarDeOcurrencia(new Ubicacion(Float.parseFloat(obj.nextLine()), Float.parseFloat(obj.nextLine())));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/metamapa/domain/Ubicacion.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/metamapa/domain/Ubicacion.java" />
              <option name="originalContent" value="package com.metamapa.domain;&#10;&#10;import jakarta.persistence.Embeddable;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Getter;&#10;import lombok.NoArgsConstructor;&#10;import lombok.Setter;&#10;&#10;@Getter&#10;@Setter&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@Embeddable&#10;public class Ubicacion {&#10;    private Float latitud;  // Cambio de float a Float&#10;    private Float longitud;  // Cambio de float a Float&#10;}&#10;" />
              <option name="updatedContent" value="package com.metamapa.domain;&#10;&#10;import jakarta.persistence.Embeddable;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Getter;&#10;import lombok.NoArgsConstructor;&#10;import lombok.Setter;&#10;&#10;@Getter&#10;@Setter&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@Embeddable&#10;public class Ubicacion {&#10;    private Float latitud;  // Cambio de float a Float&#10;    private Float longitud;  // Cambio de float a Float&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/metamapa/dtos/input/ArchivoInputDTO.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/metamapa/dtos/input/ArchivoInputDTO.java" />
              <option name="originalContent" value="package com.metamapa.dtos.input;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class ArchivoInputDTO {&#10;    Long idArchivo;  // Cambio de long a Long&#10;    String tipoMedia;  // Cambio de 'tipo' a 'tipoMedia'&#10;    String url;&#10;}&#10;" />
              <option name="updatedContent" value="package com.metamapa.dtos.input;&#13;&#10;&#13;&#10;import lombok.AllArgsConstructor;&#13;&#10;import lombok.Data;&#13;&#10;import lombok.NoArgsConstructor;&#13;&#10;&#13;&#10;@Data&#13;&#10;@NoArgsConstructor&#13;&#10;@AllArgsConstructor&#13;&#10;public class ArchivoInputDTO {&#13;&#10;    Long idArchivo;  // Cambio de long a Long&#13;&#10;    String tipoMedia;  // Cambio de 'tipo' a 'tipoMedia'&#13;&#10;    String url;&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/metamapa/dtos/input/ContribuyenteInputDTO.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/metamapa/dtos/input/ContribuyenteInputDTO.java" />
              <option name="originalContent" value="package com.metamapa.dtos.input;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class ContribuyenteInputDTO {&#10;    String nombre;&#10;    String apellido;&#10;    Integer edad;  // Cambio de int a Integer&#10;    boolean anonimo;&#10;}&#10;" />
              <option name="updatedContent" value="package com.metamapa.dtos.input;&#13;&#10;&#13;&#10;import lombok.AllArgsConstructor;&#13;&#10;import lombok.Data;&#13;&#10;import lombok.NoArgsConstructor;&#13;&#10;&#13;&#10;@Data&#13;&#10;@NoArgsConstructor&#13;&#10;@AllArgsConstructor&#13;&#10;public class ContribuyenteInputDTO {&#13;&#10;    String nombre;&#13;&#10;    String apellido;&#13;&#10;    Integer edad;  // Cambio de int a Integer&#13;&#10;    boolean anonimo;&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/metamapa/dtos/input/UbicacionInputDTO.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/metamapa/dtos/input/UbicacionInputDTO.java" />
              <option name="originalContent" value="package com.metamapa.dtos.input;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;public class UbicacionInputDTO {&#10;    Float latitud;  // Cambio de float a Float&#10;    Float longitud;  // Cambio de float a Float&#10;}&#10;" />
              <option name="updatedContent" value="package com.metamapa.dtos.input;&#13;&#10;&#13;&#10;import lombok.AllArgsConstructor;&#13;&#10;import lombok.Data;&#13;&#10;import lombok.NoArgsConstructor;&#13;&#10;&#13;&#10;@Data&#13;&#10;@NoArgsConstructor&#13;&#10;@AllArgsConstructor&#13;&#10;public class UbicacionInputDTO {&#13;&#10;    Float latitud;  // Cambio de float a Float&#13;&#10;    Float longitud;  // Cambio de float a Float&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/metamapa/services/ServicioContribuciones.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/metamapa/services/ServicioContribuciones.java" />
              <option name="originalContent" value="package com.metamapa.services;&#10;&#10;import com.metamapa.domain.*;&#10;import com.metamapa.dtos.input.ArchivoInputDTO;&#10;import com.metamapa.dtos.input.ContribucionInputDTO;&#10;import com.metamapa.dtos.input.HechoInputDTO;&#10;import com.metamapa.dtos.input.UbicacionInputDTO;&#10;import com.metamapa.dtos.output.*;&#10;import com.metamapa.exceptions.DatosInvalidosException;&#10;import com.metamapa.exceptions.EdicionNoPermitidaException;&#10;import com.metamapa.exceptions.RecursoNoEncontradoException;&#10;import com.metamapa.mappers.ArchivoMapper;&#10;import com.metamapa.mappers.ContribucionMapper;&#10;import com.metamapa.mappers.HechoMapper;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Service;&#10;import com.metamapa.repository.IContribucionesRepository;&#10;&#10;import java.time.LocalDate;&#10;&#10;@Service&#10;public class ServicioContribuciones {&#10;    @Autowired&#10;    private IContribucionesRepository repositorio;&#10;    final private PoliticaEdicion politicaEdicion= new PoliticaEdicion();&#10;    @Autowired&#10;    private ServicioContribuyente servicioContribuyente;&#10;    private HechoMapper hechoMapper = new HechoMapper();&#10;    private ArchivoMapper archivoMapper = new ArchivoMapper();&#10;    private ContribucionMapper contribucionMapper = new ContribucionMapper();&#10;&#10;    public Long crear(ContribucionInputDTO contribucionInputDTO){&#10;        // Validaciones&#10;        if (contribucionInputDTO == null) {&#10;            throw new DatosInvalidosException(&quot;Los datos de la contribución no pueden ser nulos&quot;);&#10;        }&#10;        if (contribucionInputDTO.getIdContribuyente() == null) {&#10;            throw new DatosInvalidosException(&quot;El ID del contribuyente es obligatorio&quot;);&#10;        }&#10;        if (contribucionInputDTO.getHecho() == null) {&#10;            throw new DatosInvalidosException(&quot;El hecho es obligatorio&quot;);&#10;        }&#10;&#10;        validarHecho(contribucionInputDTO.getHecho());&#10;&#10;        Hecho hecho = hechoMapper.hechoDtoToHecho(contribucionInputDTO.getHecho());&#10;        Contribucion contribucion = new Contribucion();&#10;        contribucion.setHecho(hecho);&#10;        contribucion.getRevision().setContribucion(contribucion);&#10;        contribucion.setFechaDeCarga(LocalDate.now());&#10;&#10;        Contribuyente contribuyente = servicioContribuyente.buscarContribuyente(contribucionInputDTO.getIdContribuyente());&#10;        contribucion.setContribuyente(contribuyente);&#10;&#10;        repositorio.save(contribucion);&#10;        return contribucion.getId();&#10;    }&#10;&#10;    public void editar(long idContribucion, HechoInputDTO dto){&#10;        // Validaciones&#10;        if (dto == null) {&#10;            throw new DatosInvalidosException(&quot;Los datos del hecho no pueden ser nulos&quot;);&#10;        }&#10;        validarHecho(dto);&#10;&#10;        Contribucion contribucion = repositorio.findById(idContribucion)&#10;                .orElseThrow(() -&gt; new RecursoNoEncontradoException(&quot;Contribución no encontrada con ID: &quot; + idContribucion));&#10;&#10;        if (contribucion.getFechaDeCarga() == null) {&#10;            contribucion.setFechaDeCarga(LocalDate.now());&#10;        }&#10;&#10;        if (!politicaEdicion.puedeEditar(contribucion.getFechaDeCarga())){&#10;            throw new EdicionNoPermitidaException(&quot;No se puede editar la contribución después de 7 días&quot;);&#10;        }&#10;&#10;        Hecho hecho = hechoMapper.hechoDtoToHecho(dto);&#10;        contribucion.setHecho(hecho);&#10;        contribucion.getRevision().setEstado(EstadoRevision.PENDIENTE);&#10;        repositorio.save(contribucion);&#10;    }&#10;&#10;    public void adjuntarArchivo(long idContribucion, ArchivoInputDTO dto){&#10;        // Validaciones&#10;        if (dto == null) {&#10;            throw new DatosInvalidosException(&quot;Los datos del archivo no pueden ser nulos&quot;);&#10;        }&#10;        if (dto.getUrl() == null || dto.getUrl().trim().isEmpty()) {&#10;            throw new DatosInvalidosException(&quot;La URL del archivo es obligatoria&quot;);&#10;        }&#10;        if (dto.getTipo() == null) {&#10;            throw new DatosInvalidosException(&quot;El tipo de media es obligatorio&quot;);&#10;        }&#10;&#10;        Contribucion contribucion = repositorio.findById(idContribucion)&#10;                .orElseThrow(() -&gt; new RecursoNoEncontradoException(&quot;Contribución no encontrada con ID: &quot; + idContribucion));&#10;&#10;        Archivo archivo = archivoMapper.archivoDtoToArchivo(dto);&#10;        contribucion.getHecho().setAdjunto(archivo);&#10;        repositorio.save(contribucion);&#10;    }&#10;&#10;    public ContribucionOutputDTO obtener(long id){&#10;        Contribucion c = repositorio.findById(id)&#10;                .orElseThrow(() -&gt; new RecursoNoEncontradoException(&quot;Contribución no encontrada con ID: &quot; + id));&#10;&#10;        ContribucionOutputDTO dto = contribucionMapper.contribucionToOutputDTO(c);&#10;        return dto;&#10;    }&#10;&#10;    private void validarHecho(HechoInputDTO hecho) {&#10;        if (hecho.getTitulo() == null || hecho.getTitulo().trim().isEmpty()) {&#10;            throw new DatosInvalidosException(&quot;El título del hecho es obligatorio&quot;);&#10;        }&#10;        if (hecho.getTitulo().length() &gt; 200) {&#10;            throw new DatosInvalidosException(&quot;El título no puede exceder 200 caracteres&quot;);&#10;        }&#10;        if (hecho.getDescripcion() == null || hecho.getDescripcion().trim().isEmpty()) {&#10;            throw new DatosInvalidosException(&quot;La descripción del hecho es obligatoria&quot;);&#10;        }&#10;        if (hecho.getFecha() == null) {&#10;            throw new DatosInvalidosException(&quot;La fecha del hecho es obligatoria&quot;);&#10;        }&#10;        if (hecho.getFecha().isAfter(LocalDate.now())) {&#10;            throw new DatosInvalidosException(&quot;La fecha del hecho no puede ser futura&quot;);&#10;        }&#10;        if (hecho.getUbicacion() == null) {&#10;            throw new DatosInvalidosException(&quot;La ubicación es obligatoria&quot;);&#10;        }&#10;&#10;        validarUbicacion(hecho.getUbicacion());&#10;&#10;        if (hecho.getCategoria() == null || hecho.getCategoria().trim().isEmpty()) {&#10;            throw new DatosInvalidosException(&quot;La categoría es obligatoria&quot;);&#10;        }&#10;    }&#10;&#10;    private void validarUbicacion(UbicacionInputDTO ubicacion) {&#10;        if (ubicacion.getLatitud() == null || ubicacion.getLongitud() == null) {&#10;            throw new DatosInvalidosException(&quot;La latitud y longitud son obligatorias&quot;);&#10;        }&#10;        if (ubicacion.getLatitud() &lt; -90 || ubicacion.getLatitud() &gt; 90) {&#10;            throw new DatosInvalidosException(&quot;La latitud debe estar entre -90 y 90&quot;);&#10;        }&#10;        if (ubicacion.getLongitud() &lt; -180 || ubicacion.getLongitud() &gt; 180) {&#10;            throw new DatosInvalidosException(&quot;La longitud debe estar entre -180 y 180&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.metamapa.services;&#10;&#10;import com.metamapa.domain.*;&#10;import com.metamapa.dtos.input.ArchivoInputDTO;&#10;import com.metamapa.dtos.input.ContribucionInputDTO;&#10;import com.metamapa.dtos.input.HechoInputDTO;&#10;import com.metamapa.dtos.input.UbicacionInputDTO;&#10;import com.metamapa.dtos.output.*;&#10;import com.metamapa.exceptions.DatosInvalidosException;&#10;import com.metamapa.exceptions.EdicionNoPermitidaException;&#10;import com.metamapa.exceptions.RecursoNoEncontradoException;&#10;import com.metamapa.mappers.ArchivoMapper;&#10;import com.metamapa.mappers.ContribucionMapper;&#10;import com.metamapa.mappers.HechoMapper;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Service;&#10;import com.metamapa.repository.IContribucionesRepository;&#10;&#10;import java.time.LocalDate;&#10;&#10;@Service&#10;public class ServicioContribuciones {&#10;    @Autowired&#10;    private IContribucionesRepository repositorio;&#10;    final private PoliticaEdicion politicaEdicion= new PoliticaEdicion();&#10;    @Autowired&#10;    private ServicioContribuyente servicioContribuyente;&#10;    private HechoMapper hechoMapper = new HechoMapper();&#10;    private ArchivoMapper archivoMapper = new ArchivoMapper();&#10;    private ContribucionMapper contribucionMapper = new ContribucionMapper();&#10;&#10;    public Long crear(ContribucionInputDTO contribucionInputDTO){&#10;        // Validaciones&#10;        if (contribucionInputDTO == null) {&#10;            throw new DatosInvalidosException(&quot;Los datos de la contribución no pueden ser nulos&quot;);&#10;        }&#10;        if (contribucionInputDTO.getIdContribuyente() == null) {&#10;            throw new DatosInvalidosException(&quot;El ID del contribuyente es obligatorio&quot;);&#10;        }&#10;        if (contribucionInputDTO.getHecho() == null) {&#10;            throw new DatosInvalidosException(&quot;El hecho es obligatorio&quot;);&#10;        }&#10;&#10;        validarHecho(contribucionInputDTO.getHecho());&#10;&#10;        Hecho hecho = hechoMapper.hechoDtoToHecho(contribucionInputDTO.getHecho());&#10;        Contribucion contribucion = new Contribucion();&#10;        contribucion.setHecho(hecho);&#10;        contribucion.getRevision().setContribucion(contribucion);&#10;        contribucion.setFechaDeCarga(LocalDate.now());&#10;&#10;        Contribuyente contribuyente = servicioContribuyente.buscarContribuyente(contribucionInputDTO.getIdContribuyente());&#10;        contribucion.setContribuyente(contribuyente);&#10;&#10;        repositorio.save(contribucion);&#10;        return contribucion.getId();&#10;    }&#10;&#10;    public void editar(long idContribucion, HechoInputDTO dto){&#10;        // Validaciones&#10;        if (dto == null) {&#10;            throw new DatosInvalidosException(&quot;Los datos del hecho no pueden ser nulos&quot;);&#10;        }&#10;        validarHecho(dto);&#10;&#10;        Contribucion contribucion = repositorio.findById(idContribucion)&#10;                .orElseThrow(() -&gt; new RecursoNoEncontradoException(&quot;Contribución no encontrada con ID: &quot; + idContribucion));&#10;&#10;        if (contribucion.getFechaDeCarga() == null) {&#10;            contribucion.setFechaDeCarga(LocalDate.now());&#10;        }&#10;&#10;        if (!politicaEdicion.puedeEditar(contribucion.getFechaDeCarga())){&#10;            throw new EdicionNoPermitidaException(&quot;No se puede editar la contribución después de 7 días&quot;);&#10;        }&#10;&#10;        Hecho hecho = hechoMapper.hechoDtoToHecho(dto);&#10;        contribucion.setHecho(hecho);&#10;        contribucion.getRevision().setEstado(EstadoRevision.PENDIENTE);&#10;        repositorio.save(contribucion);&#10;    }&#10;&#10;    public void adjuntarArchivo(long idContribucion, ArchivoInputDTO dto){&#10;        // Validaciones&#10;        if (dto == null) {&#10;            throw new DatosInvalidosException(&quot;Los datos del archivo no pueden ser nulos&quot;);&#10;        }&#10;        if (dto.getUrl() == null || dto.getUrl().trim().isEmpty()) {&#10;            throw new DatosInvalidosException(&quot;La URL del archivo es obligatoria&quot;);&#10;        }&#10;        if (dto.getTipo() == null) {&#10;            throw new DatosInvalidosException(&quot;El tipo de media es obligatorio&quot;);&#10;        }&#10;&#10;        Contribucion contribucion = repositorio.findById(idContribucion)&#10;                .orElseThrow(() -&gt; new RecursoNoEncontradoException(&quot;Contribución no encontrada con ID: &quot; + idContribucion));&#10;&#10;        Archivo archivo = archivoMapper.archivoDtoToArchivo(dto);&#10;        contribucion.getHecho().setAdjunto(archivo);&#10;        repositorio.save(contribucion);&#10;    }&#10;&#10;    public ContribucionOutputDTO obtener(long id){&#10;        Contribucion c = repositorio.findById(id)&#10;                .orElseThrow(() -&gt; new RecursoNoEncontradoException(&quot;Contribución no encontrada con ID: &quot; + id));&#10;&#10;        ContribucionOutputDTO dto = contribucionMapper.contribucionToOutputDTO(c);&#10;        return dto;&#10;    }&#10;&#10;    private void validarHecho(HechoInputDTO hecho) {&#10;        if (hecho.getTitulo() == null || hecho.getTitulo().trim().isEmpty()) {&#10;            throw new DatosInvalidosException(&quot;El título del hecho es obligatorio&quot;);&#10;        }&#10;        if (hecho.getTitulo().length() &gt; 200) {&#10;            throw new DatosInvalidosException(&quot;El título no puede exceder 200 caracteres&quot;);&#10;        }&#10;        if (hecho.getDescripcion() == null || hecho.getDescripcion().trim().isEmpty()) {&#10;            throw new DatosInvalidosException(&quot;La descripción del hecho es obligatoria&quot;);&#10;        }&#10;        if (hecho.getFecha() == null) {&#10;            throw new DatosInvalidosException(&quot;La fecha del hecho es obligatoria&quot;);&#10;        }&#10;        if (hecho.getFecha().isAfter(LocalDate.now())) {&#10;            throw new DatosInvalidosException(&quot;La fecha del hecho no puede ser futura&quot;);&#10;        }&#10;        if (hecho.getUbicacion() == null) {&#10;            throw new DatosInvalidosException(&quot;La ubicación es obligatoria&quot;);&#10;        }&#10;&#10;        validarUbicacion(hecho.getUbicacion());&#10;&#10;        if (hecho.getCategoria() == null || hecho.getCategoria().trim().isEmpty()) {&#10;            throw new DatosInvalidosException(&quot;La categoría es obligatoria&quot;);&#10;        }&#10;    }&#10;&#10;    private void validarUbicacion(UbicacionInputDTO ubicacion) {&#10;        if (ubicacion.getLatitud() == null || ubicacion.getLongitud() == null) {&#10;            throw new DatosInvalidosException(&quot;La latitud y longitud son obligatorias&quot;);&#10;        }&#10;        if (ubicacion.getLatitud() &lt; -90 || ubicacion.getLatitud() &gt; 90) {&#10;            throw new DatosInvalidosException(&quot;La latitud debe estar entre -90 y 90&quot;);&#10;        }&#10;        if (ubicacion.getLongitud() &lt; -180 || ubicacion.getLongitud() &gt; 180) {&#10;            throw new DatosInvalidosException(&quot;La longitud debe estar entre -180 y 180&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/metamapa/services/ServicioContribuyente.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/metamapa/services/ServicioContribuyente.java" />
              <option name="originalContent" value="package com.metamapa.services;&#10;&#10;import com.metamapa.domain.Contribuyente;&#10;import com.metamapa.dtos.input.ContribuyenteInputDTO;&#10;import com.metamapa.exceptions.DatosInvalidosException;&#10;import com.metamapa.exceptions.RecursoNoEncontradoException;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Service;&#10;import com.metamapa.repository.IContribuyentesRepository;&#10;&#10;@Service&#10;public class ServicioContribuyente {&#10;    @Autowired&#10;    private IContribuyentesRepository repositorio;&#10;&#10;    public long registrarContribuyente(ContribuyenteInputDTO contribuyenteInputDTO){&#10;        // Validaciones&#10;        if (contribuyenteInputDTO == null) {&#10;            throw new DatosInvalidosException(&quot;Los datos del contribuyente no pueden ser nulos&quot;);&#10;        }&#10;        &#10;        // Validar edad si se proporciona&#10;        if (contribuyenteInputDTO.getEdad() != null) {&#10;            if (contribuyenteInputDTO.getEdad() &lt; 0 || contribuyenteInputDTO.getEdad() &gt; 150) {&#10;                throw new DatosInvalidosException(&quot;La edad debe estar entre 0 y 150 años&quot;);&#10;            }&#10;        }&#10;        &#10;        // Validar que si proporciona nombre o apellido, ambos deben estar presentes&#10;        boolean tieneNombre = contribuyenteInputDTO.getNombre() != null &amp;&amp; !contribuyenteInputDTO.getNombre().trim().isEmpty();&#10;        boolean tieneApellido = contribuyenteInputDTO.getApellido() != null &amp;&amp; !contribuyenteInputDTO.getApellido().trim().isEmpty();&#10;        &#10;        if (tieneNombre &amp;&amp; !tieneApellido) {&#10;            throw new DatosInvalidosException(&quot;Si proporciona nombre, debe proporcionar también el apellido&quot;);&#10;        }&#10;        if (!tieneNombre &amp;&amp; tieneApellido) {&#10;            throw new DatosInvalidosException(&quot;Si proporciona apellido, debe proporcionar también el nombre&quot;);&#10;        }&#10;        &#10;        Contribuyente nuevo = new Contribuyente(contribuyenteInputDTO.getNombre(),&#10;                                                contribuyenteInputDTO.getApellido(),&#10;                                                contribuyenteInputDTO.getEdad());&#10;        if(contribuyenteInputDTO.getNombre() == null &amp;&amp; contribuyenteInputDTO.getApellido() == null){&#10;            nuevo.setAnonimo(true);&#10;        }&#10;        repositorio.save(nuevo);&#10;        return nuevo.getId();&#10;    }&#10;&#10;    public Contribuyente buscarContribuyente(Long id){&#10;        if (id == null || id &lt;= 0) {&#10;            throw new DatosInvalidosException(&quot;El ID del contribuyente debe ser un número positivo&quot;);&#10;        }&#10;        &#10;        return repositorio.findById(id)&#10;                .orElseThrow(() -&gt; new RecursoNoEncontradoException(&quot;Contribuyente no encontrado con ID: &quot; + id));&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.metamapa.services;&#10;&#10;import com.metamapa.domain.Contribuyente;&#10;import com.metamapa.dtos.input.ContribuyenteInputDTO;&#10;import com.metamapa.exceptions.DatosInvalidosException;&#10;import com.metamapa.exceptions.RecursoNoEncontradoException;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Service;&#10;import com.metamapa.repository.IContribuyentesRepository;&#10;&#10;@Service&#10;public class ServicioContribuyente {&#10;    @Autowired&#10;    private IContribuyentesRepository repositorio;&#10;&#10;    public long registrarContribuyente(ContribuyenteInputDTO contribuyenteInputDTO){&#10;        // Validaciones&#10;        if (contribuyenteInputDTO == null) {&#10;            throw new DatosInvalidosException(&quot;Los datos del contribuyente no pueden ser nulos&quot;);&#10;        }&#10;        &#10;        // Validar edad si se proporciona&#10;        if (contribuyenteInputDTO.getEdad() != null) {&#10;            if (contribuyenteInputDTO.getEdad() &lt; 0 || contribuyenteInputDTO.getEdad() &gt; 150) {&#10;                throw new DatosInvalidosException(&quot;La edad debe estar entre 0 y 150 años&quot;);&#10;            }&#10;        }&#10;        &#10;        // Validar que si proporciona nombre o apellido, ambos deben estar presentes&#10;        boolean tieneNombre = contribuyenteInputDTO.getNombre() != null &amp;&amp; !contribuyenteInputDTO.getNombre().trim().isEmpty();&#10;        boolean tieneApellido = contribuyenteInputDTO.getApellido() != null &amp;&amp; !contribuyenteInputDTO.getApellido().trim().isEmpty();&#10;        &#10;        if (tieneNombre &amp;&amp; !tieneApellido) {&#10;            throw new DatosInvalidosException(&quot;Si proporciona nombre, debe proporcionar también el apellido&quot;);&#10;        }&#10;        if (!tieneNombre &amp;&amp; tieneApellido) {&#10;            throw new DatosInvalidosException(&quot;Si proporciona apellido, debe proporcionar también el nombre&quot;);&#10;        }&#10;        &#10;        Contribuyente nuevo = new Contribuyente(contribuyenteInputDTO.getNombre(),&#10;                                                contribuyenteInputDTO.getApellido(),&#10;                                                contribuyenteInputDTO.getEdad());&#10;        if(contribuyenteInputDTO.getNombre() == null &amp;&amp; contribuyenteInputDTO.getApellido() == null){&#10;            nuevo.setAnonimo(true);&#10;        }&#10;        repositorio.save(nuevo);&#10;        return nuevo.getId();&#10;    }&#10;&#10;    public Contribuyente buscarContribuyente(Long id){&#10;        if (id == null || id &lt;= 0) {&#10;            throw new DatosInvalidosException(&quot;El ID del contribuyente debe ser un número positivo&quot;);&#10;        }&#10;        &#10;        return repositorio.findById(id)&#10;                .orElseThrow(() -&gt; new RecursoNoEncontradoException(&quot;Contribuyente no encontrado con ID: &quot; + id));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/metamapa/services/ServicioRevisiones.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/metamapa/services/ServicioRevisiones.java" />
              <option name="originalContent" value="// services/ServicioDeRevision.java&#10;package com.metamapa.services;&#10;&#10;import com.metamapa.infrastructure.Outbox.BandejaDeSalida;&#10;import com.metamapa.infrastructure.Outbox.PreparadorParaAgregador;&#10;import com.metamapa.domain.*;&#10;import com.metamapa.dtos.output.ContribucionOutputDTO;&#10;import com.metamapa.dtos.output.HechoOutputDTO;&#10;import com.metamapa.dtos.output.RevisionOutputDTO;&#10;import com.metamapa.exceptions.DatosInvalidosException;&#10;import com.metamapa.exceptions.RecursoNoEncontradoException;&#10;import lombok.RequiredArgsConstructor;&#10;import com.metamapa.mappers.ContribucionMapper;&#10;import com.metamapa.mappers.RevisionMapper;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;import com.metamapa.repository.IContribucionesRepository;&#10;&#10;import java.util.List;&#10;&#10;@Service&#10;@RequiredArgsConstructor     // inyección por constructor (Spring)&#10;public class ServicioRevisiones {&#10;    @Autowired&#10;    private final IContribucionesRepository repo;&#10;    @Autowired&#10;    private final PreparadorParaAgregador preparador;&#10;    @Autowired&#10;    private final BandejaDeSalida outbox;&#10;    @Autowired&#10;    private final RevisionMapper revisionMapper;&#10;    @Autowired&#10;    private final ContribucionMapper contribucionMapper;&#10;&#10;&#10;    @Transactional&#10;    public void aceptar(Long idContribucion, String comentarios) {&#10;        // Validaciones&#10;        if (idContribucion == null || idContribucion &lt;= 0) {&#10;            throw new DatosInvalidosException(&quot;El ID de contribución debe ser un número positivo&quot;);&#10;        }&#10;&#10;        Contribucion contribucion = repo.findById(idContribucion)&#10;                .orElseThrow(() -&gt; new RecursoNoEncontradoException(&quot;Contribución no encontrada con ID: &quot; + idContribucion));&#10;&#10;        Revision revision = contribucion.getRevision();&#10;&#10;        // Validar que esté en estado pendiente&#10;        if (revision.getEstado() != EstadoRevision.PENDIENTE) {&#10;            throw new DatosInvalidosException(&quot;Solo se pueden aceptar revisiones en estado PENDIENTE. Estado actual: &quot; + revision.getEstado());&#10;        }&#10;&#10;        revision.setEstado(EstadoRevision.ACEPTADA);&#10;        revision.setMensaje(comentarios);&#10;        repo.save(contribucion);&#10;&#10;        outbox.agregar(preparador.preparar(contribucion));  // Cambio de save() a agregar()&#10;    }&#10;&#10;    public List&lt;ContribucionOutputDTO&gt; listarPendientes(){&#10;        List&lt;Contribucion&gt; contribuciones = repo.findAll();&#10;        return contribuciones.stream()&#10;                .filter(c -&gt; c.getRevision().getEstado() == EstadoRevision.PENDIENTE)&#10;                .map(contribucionMapper::contribucionToOutputDTO)&#10;                .toList();&#10;    }&#10;&#10;&#10;    @Transactional&#10;    public void aceptarConSugerencias(Long idContribucion, String comentarios) {&#10;        // Validaciones&#10;        if (idContribucion == null || idContribucion &lt;= 0) {&#10;            throw new DatosInvalidosException(&quot;El ID de contribución debe ser un número positivo&quot;);&#10;        }&#10;        if (comentarios == null || comentarios.trim().isEmpty()) {&#10;            throw new DatosInvalidosException(&quot;Los comentarios son obligatorios al aceptar con sugerencias&quot;);&#10;        }&#10;&#10;        Contribucion c = repo.findById(idContribucion)&#10;                .orElseThrow(() -&gt; new RecursoNoEncontradoException(&quot;Contribución no encontrada con ID: &quot; + idContribucion));&#10;&#10;        Revision revision = c.getRevision();&#10;&#10;        // Validar que esté en estado pendiente&#10;        if (revision.getEstado() != EstadoRevision.PENDIENTE) {&#10;            throw new DatosInvalidosException(&quot;Solo se pueden revisar contribuciones en estado PENDIENTE. Estado actual: &quot; + revision.getEstado());&#10;        }&#10;&#10;        revision.setEstado(EstadoRevision.ACEPTADA_CON_SUGERENCIA);&#10;        revision.setMensaje(comentarios);&#10;        repo.save(c);&#10;    }&#10;&#10;    @Transactional&#10;    public void rechazar(Long idContribucion, String comentarios) {&#10;        // Validaciones&#10;        if (idContribucion == null || idContribucion &lt;= 0) {&#10;            throw new DatosInvalidosException(&quot;El ID de contribución debe ser un número positivo&quot;);&#10;        }&#10;        if (comentarios == null || comentarios.trim().isEmpty()) {&#10;            throw new DatosInvalidosException(&quot;El motivo del rechazo es obligatorio&quot;);&#10;        }&#10;&#10;        Contribucion c = repo.findById(idContribucion)&#10;                .orElseThrow(() -&gt; new RecursoNoEncontradoException(&quot;Contribución no encontrada con ID: &quot; + idContribucion));&#10;&#10;        Revision revision = c.getRevision();&#10;&#10;        // Validar que esté en estado pendiente&#10;        if (revision.getEstado() != EstadoRevision.PENDIENTE) {&#10;            throw new DatosInvalidosException(&quot;Solo se pueden rechazar contribuciones en estado PENDIENTE. Estado actual: &quot; + revision.getEstado());&#10;        }&#10;&#10;        revision.setEstado(EstadoRevision.RECHAZADA);&#10;        revision.setMensaje(comentarios);&#10;        repo.save(c);&#10;    }&#10;&#10;    public RevisionOutputDTO detalle(Long idContribucion) {&#10;        // Validaciones&#10;        if (idContribucion == null || idContribucion &lt;= 0) {&#10;            throw new DatosInvalidosException(&quot;El ID de contribución debe ser un número positivo&quot;);&#10;        }&#10;&#10;        Contribucion c = repo.findById(idContribucion)&#10;                .orElseThrow(() -&gt; new RecursoNoEncontradoException(&quot;Contribución no encontrada con ID: &quot; + idContribucion));&#10;&#10;        Revision revision = c.getRevision();&#10;        return revisionMapper.revisionToRevisionOutputDTO(revision);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="// services/ServicioDeRevision.java&#10;package com.metamapa.services;&#10;&#10;import com.metamapa.infrastructure.Outbox.BandejaDeSalida;&#10;import com.metamapa.infrastructure.Outbox.PreparadorParaAgregador;&#10;import com.metamapa.domain.*;&#10;import com.metamapa.dtos.output.ContribucionOutputDTO;&#10;import com.metamapa.dtos.output.HechoOutputDTO;&#10;import com.metamapa.dtos.output.RevisionOutputDTO;&#10;import com.metamapa.exceptions.DatosInvalidosException;&#10;import com.metamapa.exceptions.RecursoNoEncontradoException;&#10;import lombok.RequiredArgsConstructor;&#10;import com.metamapa.mappers.ContribucionMapper;&#10;import com.metamapa.mappers.RevisionMapper;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;import com.metamapa.repository.IContribucionesRepository;&#10;&#10;import java.util.List;&#10;&#10;@Service&#10;@RequiredArgsConstructor     // inyección por constructor (Spring)&#10;public class ServicioRevisiones {&#10;    @Autowired&#10;    private final IContribucionesRepository repo;&#10;    @Autowired&#10;    private final PreparadorParaAgregador preparador;&#10;    @Autowired&#10;    private final BandejaDeSalida outbox;&#10;    @Autowired&#10;    private final RevisionMapper revisionMapper;&#10;    @Autowired&#10;    private final ContribucionMapper contribucionMapper;&#10;&#10;&#10;    @Transactional&#10;    public void aceptar(Long idContribucion, String comentarios) {&#10;        // Validaciones&#10;        if (idContribucion == null || idContribucion &lt;= 0) {&#10;            throw new DatosInvalidosException(&quot;El ID de contribución debe ser un número positivo&quot;);&#10;        }&#10;&#10;        Contribucion contribucion = repo.findById(idContribucion)&#10;                .orElseThrow(() -&gt; new RecursoNoEncontradoException(&quot;Contribución no encontrada con ID: &quot; + idContribucion));&#10;&#10;        Revision revision = contribucion.getRevision();&#10;&#10;        // Validar que esté en estado pendiente&#10;        if (revision.getEstado() != EstadoRevision.PENDIENTE) {&#10;            throw new DatosInvalidosException(&quot;Solo se pueden aceptar revisiones en estado PENDIENTE. Estado actual: &quot; + revision.getEstado());&#10;        }&#10;&#10;        revision.setEstado(EstadoRevision.ACEPTADA);&#10;        revision.setMensaje(comentarios);&#10;        repo.save(contribucion);&#10;&#10;        outbox.agregar(preparador.preparar(contribucion));  // Cambio de save() a agregar()&#10;    }&#10;&#10;    public List&lt;ContribucionOutputDTO&gt; listarPendientes(){&#10;        List&lt;Contribucion&gt; contribuciones = repo.findAll();&#10;        return contribuciones.stream()&#10;                .filter(c -&gt; c.getRevision().getEstado() == EstadoRevision.PENDIENTE)&#10;                .map(contribucionMapper::contribucionToOutputDTO)&#10;                .toList();&#10;    }&#10;&#10;&#10;    @Transactional&#10;    public void aceptarConSugerencias(Long idContribucion, String comentarios) {&#10;        // Validaciones&#10;        if (idContribucion == null || idContribucion &lt;= 0) {&#10;            throw new DatosInvalidosException(&quot;El ID de contribución debe ser un número positivo&quot;);&#10;        }&#10;        if (comentarios == null || comentarios.trim().isEmpty()) {&#10;            throw new DatosInvalidosException(&quot;Los comentarios son obligatorios al aceptar con sugerencias&quot;);&#10;        }&#10;&#10;        Contribucion c = repo.findById(idContribucion)&#10;                .orElseThrow(() -&gt; new RecursoNoEncontradoException(&quot;Contribución no encontrada con ID: &quot; + idContribucion));&#10;&#10;        Revision revision = c.getRevision();&#10;&#10;        // Validar que esté en estado pendiente&#10;        if (revision.getEstado() != EstadoRevision.PENDIENTE) {&#10;            throw new DatosInvalidosException(&quot;Solo se pueden revisar contribuciones en estado PENDIENTE. Estado actual: &quot; + revision.getEstado());&#10;        }&#10;&#10;        revision.setEstado(EstadoRevision.ACEPTADA_CON_SUGERENCIA);&#10;        revision.setMensaje(comentarios);&#10;        repo.save(c);&#10;    }&#10;&#10;    @Transactional&#10;    public void rechazar(Long idContribucion, String comentarios) {&#10;        // Validaciones&#10;        if (idContribucion == null || idContribucion &lt;= 0) {&#10;            throw new DatosInvalidosException(&quot;El ID de contribución debe ser un número positivo&quot;);&#10;        }&#10;        if (comentarios == null || comentarios.trim().isEmpty()) {&#10;            throw new DatosInvalidosException(&quot;El motivo del rechazo es obligatorio&quot;);&#10;        }&#10;&#10;        Contribucion c = repo.findById(idContribucion)&#10;                .orElseThrow(() -&gt; new RecursoNoEncontradoException(&quot;Contribución no encontrada con ID: &quot; + idContribucion));&#10;&#10;        Revision revision = c.getRevision();&#10;&#10;        // Validar que esté en estado pendiente&#10;        if (revision.getEstado() != EstadoRevision.PENDIENTE) {&#10;            throw new DatosInvalidosException(&quot;Solo se pueden rechazar contribuciones en estado PENDIENTE. Estado actual: &quot; + revision.getEstado());&#10;        }&#10;&#10;        revision.setEstado(EstadoRevision.RECHAZADA);&#10;        revision.setMensaje(comentarios);&#10;        repo.save(c);&#10;    }&#10;&#10;    public RevisionOutputDTO detalle(Long idContribucion) {&#10;        // Validaciones&#10;        if (idContribucion == null || idContribucion &lt;= 0) {&#10;            throw new DatosInvalidosException(&quot;El ID de contribución debe ser un número positivo&quot;);&#10;        }&#10;&#10;        Contribucion c = repo.findById(idContribucion)&#10;                .orElseThrow(() -&gt; new RecursoNoEncontradoException(&quot;Contribución no encontrada con ID: &quot; + idContribucion));&#10;&#10;        Revision revision = c.getRevision();&#10;        return revisionMapper.revisionToRevisionOutputDTO(revision);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/services/ServicioContribuciones.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/services/ServicioContribuciones.java" />
              <option name="originalContent" value="package services;&#10;&#10;import domain.*;&#10;import dtos.input.ArchivoInputDTO;&#10;import dtos.input.ContribucionInputDTO;&#10;import dtos.input.HechoInputDTO;&#10;import dtos.input.UbicacionInputDTO;&#10;import dtos.output.*;&#10;import mappers.ArchivoMapper;&#10;import mappers.ContribucionMapper;&#10;import mappers.HechoMapper;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Service;&#10;import repository.IContribucionesRepository;&#10;&#10;import java.time.LocalDate;&#10;&#10;@Service&#10;public class ServicioContribuciones {&#10;    @Autowired&#10;    private IContribucionesRepository repositorio;&#10;    final private PoliticaEdicion politicaEdicion= new PoliticaEdicion();&#10;    @Autowired&#10;    private ServicioContribuyente servicioContribuyente;&#10;    private HechoMapper hechoMapper = new HechoMapper();&#10;    private ArchivoMapper archivoMapper = new ArchivoMapper();&#10;    private ContribucionMapper contribucionMapper = new ContribucionMapper();&#10;&#10;    public Long crear(ContribucionInputDTO contribucionInputDTO){&#10;        Hecho hecho = hechoMapper.hechoDtoToHecho(contribucionInputDTO.getHecho());&#10;        Contribucion contribucion = new Contribucion();&#10;        contribucion.setHecho(hecho);&#10;        contribucion.getRevision().setContribucion(contribucion);&#10;        contribucion.setFechaDeCarga(LocalDate.now()); // Establecer la fecha de carga al crear&#10;&#10;        Contribuyente contribuyente = servicioContribuyente.buscarContribuyente(contribucionInputDTO.getIdContribuyente());&#10;&#10;        contribucion.setContribuyente(contribuyente);&#10;        repositorio.guardar(contribucion);&#10;        return contribucion.getId();&#10;    };&#10;&#10;    public void editar(long idContribucion, HechoInputDTO dto){&#10;        Contribucion contribucion = repositorio.buscarPorId(idContribucion);&#10;        &#10;        // Si la contribución no tiene fechaDeCarga (fue creada antes del cambio), establecerla ahora&#10;        if (contribucion.getFechaDeCarga() == null) {&#10;            contribucion.setFechaDeCarga(LocalDate.now());&#10;        }&#10;        &#10;        if (politicaEdicion.puedeEditar(contribucion.getFechaDeCarga())){&#10;            Hecho hecho = hechoMapper.hechoDtoToHecho(dto);&#10;            contribucion.setHecho(hecho);&#10;            contribucion.getRevision().setEstado(EstadoRevision.PENDIENTE);&#10;        } else {&#10;            throw new RuntimeException(&quot;No se puede editar la contribucion despues de 7 dias.&quot;);&#10;        }&#10;    }&#10;&#10;    public void adjuntarArchivo(long idContribucion, ArchivoInputDTO dto){&#10;        Contribucion contribucion = repositorio.buscarPorId(idContribucion);&#10;        Archivo archivo = archivoMapper.archivoDtoToArchivo(dto);&#10;        contribucion.getHecho().setAdjunto(archivo);&#10;    }&#10;&#10;    public ContribucionOutputDTO obtener(long id){&#10;        Contribucion c = repositorio.buscarPorId(id);&#10;        ContribucionOutputDTO dto = contribucionMapper.contribucionToOutputDTO(c);&#10;        return dto;&#10;    }&#10;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package services;&#10;&#10;import domain.*;&#10;import dtos.input.ArchivoInputDTO;&#10;import dtos.input.ContribucionInputDTO;&#10;import dtos.input.HechoInputDTO;&#10;import dtos.input.UbicacionInputDTO;&#10;import dtos.output.*;&#10;import mappers.ArchivoMapper;&#10;import mappers.ContribucionMapper;&#10;import mappers.HechoMapper;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Service;&#10;import repository.IContribucionesRepository;&#10;&#10;import java.time.LocalDate;&#10;&#10;@Service&#10;public class ServicioContribuciones {&#10;    @Autowired&#10;    private IContribucionesRepository repositorio;&#10;    final private PoliticaEdicion politicaEdicion= new PoliticaEdicion();&#10;    @Autowired&#10;    private ServicioContribuyente servicioContribuyente;&#10;    private HechoMapper hechoMapper = new HechoMapper();&#10;    private ArchivoMapper archivoMapper = new ArchivoMapper();&#10;    private ContribucionMapper contribucionMapper = new ContribucionMapper();&#10;&#10;    public Long crear(ContribucionInputDTO contribucionInputDTO){&#10;        Hecho hecho = hechoMapper.hechoDtoToHecho(contribucionInputDTO.getHecho());&#10;        Contribucion contribucion = new Contribucion();&#10;        contribucion.setHecho(hecho);&#10;        contribucion.getRevision().setContribucion(contribucion);&#10;        contribucion.setFechaDeCarga(LocalDate.now()); // Establecer la fecha de carga al crear&#10;&#10;        Contribuyente contribuyente = servicioContribuyente.buscarContribuyente(contribucionInputDTO.getIdContribuyente());&#10;&#10;        contribucion.setContribuyente(contribuyente);&#10;        repositorio.guardar(contribucion);&#10;        return contribucion.getId();&#10;    };&#10;&#10;    public void editar(long idContribucion, HechoInputDTO dto){&#10;        Contribucion contribucion = repositorio.buscarPorId(idContribucion);&#10;        &#10;        // Si la contribución no tiene fechaDeCarga (fue creada antes del cambio), establecerla ahora&#10;        if (contribucion.getFechaDeCarga() == null) {&#10;            contribucion.setFechaDeCarga(LocalDate.now());&#10;        }&#10;        &#10;        if (politicaEdicion.puedeEditar(contribucion.getFechaDeCarga())){&#10;            Hecho hecho = hechoMapper.hechoDtoToHecho(dto);&#10;            contribucion.setHecho(hecho);&#10;            contribucion.getRevision().setEstado(EstadoRevision.PENDIENTE);&#10;        } else {&#10;            throw new RuntimeException(&quot;No se puede editar la contribucion despues de 7 dias.&quot;);&#10;        }&#10;    }&#10;&#10;    public void adjuntarArchivo(long idContribucion, ArchivoInputDTO dto){&#10;        Contribucion contribucion = repositorio.buscarPorId(idContribucion);&#10;        Archivo archivo = archivoMapper.archivoDtoToArchivo(dto);&#10;        contribucion.getHecho().setAdjunto(archivo);&#10;    }&#10;&#10;    public ContribucionOutputDTO obtener(long id){&#10;        Contribucion c = repositorio.buscarPorId(id);&#10;        ContribucionOutputDTO dto = contribucionMapper.contribucionToOutputDTO(c);&#10;        return dto;&#10;    }&#10;&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>